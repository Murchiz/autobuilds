name: Build Corretto 21 lilliput-2 Msys2 edition

on:
  schedule:
    - cron: '0 5 * * 1'
  workflow_dispatch:

env:
  UPSTREAM_REPO: corretto/corretto-21
  UPSTREAM_BRANCH: lilliput-2
  GITHUB_VARIABLE_NAME: LAST_BUILT_CORRETTO_LILLIPUT_SHA
  CORRETTO_SOURCE_DIR: corretto_source_checkout
  BUILD_JOBS: 8
  BUILD_CORES: 4
  BUILD_MEMORY: 16384
  JVM_ARGS: "-Xmx8G"

jobs:
  build_if_new_commits:
    runs-on: windows-2022
    permissions:
      contents: read
      actions: read
    steps:

      - name: Read Last Built Upstream SHA
        id: read_last_sha
        run: |
          $sha_from_var = "${{ vars[env.GITHUB_VARIABLE_NAME] || '' }}"
          echo "last_sha=$sha_from_var" >> $GITHUB_OUTPUT
        shell: pwsh

      - name: Quick SHA Check
        id: quick_check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          $needs_build = "false"
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $needs_build = "true"
          } else {
            $latest_sha = gh api repos/${{ env.UPSTREAM_REPO }}/commits/${{ env.UPSTREAM_BRANCH }} --jq .sha
            if ("${{ steps.read_last_sha.outputs.last_sha }}" -ne "$latest_sha") {
              $needs_build = "true"
            }
            echo "upstream_sha=$latest_sha" >> $env:GITHUB_OUTPUT
          }
          echo "needs_build=$needs_build" >> $env:GITHUB_OUTPUT
        shell: pwsh

      - name: Exit early if no build needed
        if: steps.quick_check.outputs.needs_build == 'false'
        run: |
          Write-Host "No new commits found. Skipping build."
          exit 0
        shell: pwsh

      - name: Set up workspace on faster D drive
        if: steps.quick_check.outputs.needs_build == 'true'
        run: |
          $workspaceOnD = "D:\gh_workspace"
          New-Item -ItemType Directory -Path $workspaceOnD -Force | Out-Null
          echo "WORKSPACE_ROOT=$workspaceOnD" >> $env:GITHUB_ENV
        shell: pwsh

      - name: Checkout upstream repository to D drive
        if: steps.quick_check.outputs.needs_build == 'true'
        id: checkout_upstream
        working-directory: D:\gh_workspace
        run: |
          git clone --depth 1 --branch ${{ env.UPSTREAM_BRANCH }} https://github.com/${{ env.UPSTREAM_REPO }}.git ${{ env.CORRETTO_SOURCE_DIR }}
          cd ${{ env.CORRETTO_SOURCE_DIR }}
          $current_sha = (git rev-parse HEAD).Trim()
          echo "sha=$current_sha" >> $env:GITHUB_OUTPUT
          $fullPath = Join-Path $env:WORKSPACE_ROOT $env:CORRETTO_SOURCE_DIR
          echo "CORRETTO_SOURCE_DIR=$fullPath" >> $env:GITHUB_ENV
        shell: pwsh

      - name: Set up Corretto 21 as Bootstrap JDK
        if: steps.quick_check.outputs.needs_build == 'true'
        uses: actions/setup-java@v4
        with:
          distribution: 'corretto'
          java-version: '21'

      - name: Install MSYS2
        if: steps.quick_check.outputs.needs_build == 'true'
        uses: msys2/setup-msys2@v2.28.0
        with:
          install: 'autoconf tar unzip zip make'
          update: true
          path-type: minimal
          location: D:\msys2_minimal

      - name: Configure build environment
        if: steps.quick_check.outputs.needs_build == 'true'
        shell: msys2 {0}
        run: |
          mkdir -p /d/tmp
          echo "export TMPDIR=/d/tmp" >> ~/.bashrc
          echo "export TMP=/d/tmp" >> ~/.bashrc
          echo "export TEMP=/d/tmp" >> ~/.bashrc

      - name: Configure Corretto Build Optimized
        if: steps.quick_check.outputs.needs_build == 'true'
        working-directory: ${{ env.CORRETTO_SOURCE_DIR }}
        shell: msys2 {0}
        run: |
          export TMPDIR=/d/tmp
          export TMP=/d/tmp
          export TEMP=/d/tmp

          BOOT_JDK_MSYS=$(cygpath -u "$JAVA_HOME")

          ./configure --with-boot-jdk="$BOOT_JDK_MSYS" \
                      --disable-warnings-as-errors \
                      --with-debug-level=release \
                      --with-native-debug-symbols=none \
                      --with-num-cores=${{ env.BUILD_CORES }} \
                      --with-memory-size=${{ env.BUILD_MEMORY }} \
                      --with-jobs=${{ env.BUILD_JOBS }} \
                      --with-boot-jdk-jvmargs="${{ env.JVM_ARGS }}" \
                      --enable-javac-server \
                      --disable-full-docs

      - name: Build Corretto make images
        if: steps.quick_check.outputs.needs_build == 'true'
        working-directory: ${{ env.CORRETTO_SOURCE_DIR }}
        shell: msys2 {0}
        run: |
          export TMPDIR=/d/tmp
          export TMP=/d/tmp
          export TEMP=/d/tmp

          make JOBS=${{ env.BUILD_JOBS }} jdk

      - name: Prepare Artifact Structure
        if: steps.quick_check.outputs.needs_build == 'true'
        id: prepare_artifact
        working-directory: ${{ env.CORRETTO_SOURCE_DIR }}
        shell: pwsh
        run: |
          # Find the actual build output directory (not .configure-support)
          $buildOutputDirs = Get-ChildItem -Path "build" -Directory | 
            Where-Object { $_.Name -notlike ".*" -and $_.Name -match "windows.*release" }
          
          if ($buildOutputDirs.Count -eq 0) {
            # If no windows*release pattern found, look for any non-hidden directory with 'jdk' subdirectory
            $buildOutputDirs = Get-ChildItem -Path "build" -Directory | 
              Where-Object { 
                $_.Name -notlike ".*" -and 
                (Test-Path (Join-Path $_.FullName "jdk"))
              }
          }
          
          $buildDir = $buildOutputDirs | Select-Object -First 1
          if (-not $buildDir) {
            Write-Host "Contents of build directory:"
            Get-ChildItem -Path "build" | ForEach-Object { Write-Host $_.Name }
            throw "Build output directory not found"
          }
          
          $jdkPath = Join-Path $buildDir.FullName "jdk"
          if (-not (Test-Path $jdkPath)) {
            Write-Host "Contents of $($buildDir.FullName):"
            Get-ChildItem -Path $buildDir.FullName | ForEach-Object { Write-Host $_.Name }
            throw "JDK directory not found at: $jdkPath"
          }
          
          Write-Host "Found JDK at: $jdkPath"
          
          # Extract version from release file
          $releaseFile = Join-Path $jdkPath "release"
          if (-not (Test-Path $releaseFile)) {
            throw "Release file not found at: $releaseFile"
          }
          
          # Read and parse the release file
          $releaseContent = Get-Content $releaseFile -Raw
          Write-Host "Release file content (first 500 chars):"
          Write-Host $releaseContent.Substring(0, [Math]::Min(500, $releaseContent.Length))
          
          # Try different patterns to extract Java version
          $javaVersion = $null
          
          # Pattern 1: JAVA_VERSION="21.0.x"
          if ($releaseContent -match 'JAVA_VERSION\s*=\s*"([^"]+)"') {
            $javaVersion = $matches[1]
          }
          # Pattern 2: JAVA_VERSION='21.0.x'
          elseif ($releaseContent -match "JAVA_VERSION\s*=\s*'([^']+)'") {
            $javaVersion = $matches[1]
          }
          # Pattern 3: JAVA_VERSION=21.0.x (no quotes)
          elseif ($releaseContent -match 'JAVA_VERSION\s*=\s*([^\s\r\n]+)') {
            $javaVersion = $matches[1]
          }
          
          if (-not $javaVersion) {
            # Try to find any line with version-like pattern
            if ($releaseContent -match '21\.\d+\.\d+') {
              $javaVersion = $matches[0]
              Write-Host "Found version pattern: $javaVersion"
            } else {
              throw "Could not extract JAVA_VERSION from release file. Please check the file format."
            }
          }
          
          Write-Host "Extracted Java version: $javaVersion"
          echo "JAVA_VERSION_EXTRACTED=$javaVersion" >> $env:GITHUB_OUTPUT
          
          # Create staging directory structure
          $stagingDir = Join-Path $env:WORKSPACE_ROOT "staging_artifact"
          $targetDirName = "corretto-21-lilliput-${javaVersion}"
          $fullTargetPath = Join-Path $stagingDir $targetDirName
          
          Write-Host "Creating staging directory: $fullTargetPath"
          New-Item -ItemType Directory -Path $fullTargetPath -Force | Out-Null
          
          # Copy JDK contents to staging directory
          Write-Host "Copying JDK contents from $jdkPath to $fullTargetPath"
          Copy-Item -Path "$jdkPath\*" -Destination $fullTargetPath -Recurse -Force
          
          # Verify the copy
          $itemCount = (Get-ChildItem -Path $fullTargetPath -Recurse | Measure-Object).Count
          Write-Host "Copied $itemCount items to staging directory"
          
          # Store staging directory path for artifact upload
          echo "STAGING_DIR=$stagingDir" >> $env:GITHUB_ENV

      - name: Upload Windows JDK Build Artifact
        if: steps.quick_check.outputs.needs_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: corretto-21-lilliput-${{ steps.prepare_artifact.outputs.JAVA_VERSION_EXTRACTED }}-windows-x64-jdk
          path: ${{ env.STAGING_DIR }}/

      - name: Update GitHub Repository Variable with PAT
        if: steps.quick_check.outputs.needs_build == 'true'
        env:
          NEW_SHA_TO_SAVE: ${{ steps.quick_check.outputs.upstream_sha || steps.checkout_upstream.outputs.sha }}
          GH_TOKEN: ${{ secrets.MY_PAT }}
        run: |
          gh variable set "${{ env.GITHUB_VARIABLE_NAME }}" --body "${NEW_SHA_TO_SAVE}" --repo "${{ github.repository }}"
        shell: bash



