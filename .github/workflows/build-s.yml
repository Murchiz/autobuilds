name: Build if Upstream Changes

on:
  workflow_dispatch: {}
  schedule:
    - cron: "0 * * * *"  # Every hour, just in case
  push:
    branches: [ main ]

permissions:
  contents: read
  actions: read

env:
  UPSTREAM_REPO: eclipse-corretto/corretto-21
  UPSTREAM_BRANCH: lilliput-2
  GITHUB_VARIABLE_NAME: LAST_BUILT_CORRETTO_LILLIPUT_SHA

jobs:
  build_if_new_commits:
    runs-on: windows-2025
    outputs:
      needs_build: ${{ steps.check_build_condition.outputs.needs_build }}

    steps:

      # 1. Read the "last built" SHA from repository variables via GitHub REST API
      - name: Read Last Built SHA
        id: read_last_sha
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const varName = process.env.TARGET_VARIABLE_NAME;
            let lastSha = "";
            try {
              const response = await github.rest.actions.getRepoVariable({
                owner,
                repo,
                name: varName
              });
              lastSha = response.data.value;
            } catch (error) {
              // If the variable does not exist yet, treat as empty
              core.info(`Variable "${varName}" not found; defaulting to empty SHA.`);
            }
            core.setOutput("last_sha", lastSha);
        env:
          TARGET_VARIABLE_NAME: ${{ env.GITHUB_VARIABLE_NAME }}

      # 2. Clone upstream branch shallowly and grab its HEAD SHA
      - name: Get Upstream SHA
        id: get_upstream_sha
        shell: pwsh
        run: |
          git clone --depth 1 --branch ${{ env.UPSTREAM_BRANCH }} https://github.com/${{ env.UPSTREAM_REPO }} temp_upstream
          Push-Location temp_upstream
          $sha = (git rev-parse HEAD).Trim()
          Pop-Location
          echo "sha=$sha" >> $GITHUB_OUTPUT

      # 3. Compare the two SHAs to decide if a build is needed
      - name: Determine if Build is Needed
        id: check_build_condition
        shell: pwsh
        run: |
          $last    = "${{ steps.read_last_sha.outputs.last_sha }}"
          $current = "${{ steps.get_upstream_sha.outputs.sha }}"
          Write-Host "Previous SHA: $last"
          Write-Host "Current  SHA: $current"
          if ($last -ne $current) {
            echo "needs_build=true" >> $GITHUB_OUTPUT
          } else {
            echo "needs_build=false" >> $GITHUB_OUTPUT
          }

      # 4. If no build is needed, exit
      - name: No Build Needed
        if: steps.check_build_condition.outputs.needs_build == 'false'
        shell: pwsh
        run: |
          Write-Host "No new upstream commit detected. Skipping build."

      # 5. Add Cygwin (or MSYS2) from the preinstalled runner image to PATH
      - name: Add Cygwin to PATH
        if: steps.check_build_condition.outputs.needs_build == 'true'
        shell: pwsh
        run: |
          if (Test-Path "C:\cygwin64\bin") {
            echo "C:\cygwin64\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          } elseif (Test-Path "C:\msys64\usr\bin") {
            echo "C:\msys64\usr\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          } else {
            Write-Error "No known Linux-style shell (Cygwin or MSYS2) found on this runner."
            exit 1
          }

      # 6. Check out the Corretto source if we do need to build
      - name: Checkout Corretto Source
        if: steps.check_build_condition.outputs.needs_build == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ env.UPSTREAM_REPO }}
          ref: ${{ env.UPSTREAM_BRANCH }}

      # 7. Set up Corretto 21 as the bootstrap JDK
      - name: Set up Bootstrap JDK
        if: steps.check_build_condition.outputs.needs_build == 'true'
        uses: actions/setup-java@v4
        with:
          distribution: corretto
          java-version: 21
          architecture: x64
        id: setup_jdk

      # 8. Run the actual build (adjust the build command to your project’s needs)
      - name: Build Corretto
        if: steps.check_build_condition.outputs.needs_build == 'true'
        shell: pwsh
        run: |
          bash -lc "cd $Env:GITHUB_WORKSPACE && make all"

      # 9. Collect the JDK output into a staging directory
      - name: Prepare Artifact Structure
        if: steps.check_build_condition.outputs.needs_build == 'true'
        id: prepare_artifact
        working-directory: ${{ github.workspace }}
        shell: pwsh
        run: |
          mkdir staging_artifact
          cp -r build/*/images/jdk/* staging_artifact/

      # 10. Upload the built JDK as an artifact
      - name: Upload Build Artifacts
        if: steps.check_build_condition.outputs.needs_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: corretto-latest-jdk
          path: staging_artifact/

      # 11. Update the “last built” repository variable with the new SHA
      - name: Update Last Built SHA Variable
        if: steps.check_build_condition.outputs.needs_build == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MY_PAT }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const varName = process.env.TARGET_VARIABLE_NAME;
            const varValue = process.env.NEW_SHA_TO_SAVE;
            await github.rest.actions.createOrUpdateRepoVariable({
              owner,
              repo,
              name: varName,
              value: varValue
            });
        env:
          NEW_SHA_TO_SAVE: ${{ steps.get_upstream_sha.outputs.sha }}
          TARGET_VARIABLE_NAME: ${{ env.GITHUB_VARIABLE_NAME }}
