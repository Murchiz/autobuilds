name: Build Corretto 21 (lilliput-2) for Windows - SECURE VERSION
on:
  schedule:
    - cron: '0 5 * * 1' 
  workflow_dispatch: 

env:
  UPSTREAM_REPO: corretto/corretto-21
  UPSTREAM_BRANCH: lilliput-2
  GITHUB_VARIABLE_NAME: LAST_BUILT_CORRETTO_LILLIPUT_SHA
  CORRETTO_SOURCE_DIR: corretto_source_checkout
  # Pin versions for security
  CYGWIN_VERSION: "3.4.10-1"
  CHOCOLATEY_VERSION: "2.2.2"

jobs:
  build_if_new_commits:
    runs-on: windows-2022  # Use stable, well-maintained runner
    permissions:
      contents: read
      actions: read
      # Use minimal permissions instead of PAT
      repository-projects: write  # For updating variables
    
    steps:
      - name: Validate Environment Variables
        run: |
          # Input validation to prevent injection
          if (-not ($env:UPSTREAM_REPO -match '^[a-zA-Z0-9._/-]+$')) {
            Write-Error "Invalid UPSTREAM_REPO format"; exit 1
          }
          if (-not ($env:UPSTREAM_BRANCH -match '^[a-zA-Z0-9._/-]+$')) {
            Write-Error "Invalid UPSTREAM_BRANCH format"; exit 1
          }
          Write-Host "Environment validation passed"
        shell: pwsh

      - name: Read Last Built Upstream SHA from GitHub Variable
        id: read_last_sha
        run: |
          # Sanitize variable name to prevent injection
          $varName = "${{ env.GITHUB_VARIABLE_NAME }}" -replace '[^a-zA-Z0-9_]', ''
          $sha_from_var = "${{ vars[env.GITHUB_VARIABLE_NAME] || '' }}"
          
          # Validate SHA format
          if ($sha_from_var -and -not ($sha_from_var -match '^[a-f0-9]{40}$')) {
            Write-Warning "Invalid SHA format in variable, treating as empty"
            $sha_from_var = ""
          }
          
          echo "last_sha=$sha_from_var" >> $env:GITHUB_OUTPUT
          Write-Host "Last built upstream SHA validated"
        shell: pwsh

      - name: Get Current Upstream SHA for Verified Repository
        id: get_upstream_sha
        run: |
          # Use parameterized git commands to prevent injection
          $repoUrl = "https://github.com/${{ env.UPSTREAM_REPO }}.git"
          $branch = "${{ env.UPSTREAM_BRANCH }}"
          
          # Validate repository URL format
          if (-not ($repoUrl -match '^https://github\.com/[a-zA-Z0-9._/-]+\.git$')) {
            Write-Error "Invalid repository URL format"; exit 1
          }
          
          # Create temporary directory with random name
          $tempDir = "temp_upstream_$(Get-Random)"
          
          try {
            # Use git with explicit parameters to prevent injection
            git clone --depth 1 --single-branch --branch $branch $repoUrl $tempDir
            if ($LASTEXITCODE -ne 0) { throw "Git clone failed" }
            
            Push-Location $tempDir
            $current_sha = (git rev-parse HEAD).Trim()
            Pop-Location
            
            # Validate SHA format
            if (-not ($current_sha -match '^[a-f0-9]{40}$')) {
              throw "Invalid SHA format returned"
            }
            
            echo "sha=$current_sha" >> $env:GITHUB_OUTPUT
            Write-Host "Current upstream SHA verified: $current_sha"
          }
          finally {
            # Secure cleanup
            if (Test-Path $tempDir) {
              Remove-Item -Recurse -Force $tempDir -ErrorAction SilentlyContinue
            }
          }
        shell: pwsh

      - name: Determine if Build is Needed
        id: check_build_condition
        run: |
          $last_sha = "${{ steps.read_last_sha.outputs.last_sha }}"
          $current_sha = "${{ steps.get_upstream_sha.outputs.sha }}"
          $needs_build = "false"
          
          # Validate both SHAs
          if ($current_sha -notmatch '^[a-f0-9]{40}$') {
            Write-Error "Invalid current SHA format"; exit 1
          }
          
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $needs_build = "true"
            Write-Host "Manual dispatch: Build forced"
          } elseif ($last_sha -ne $current_sha) {
            $needs_build = "true"
            Write-Host "SHA changed: Build needed"
          } else {
            Write-Host "No changes detected"
          }
          
          echo "needs_build=$needs_build" >> $env:GITHUB_OUTPUT
        shell: pwsh

      - name: Checkout Corretto source (if build is needed)
        if: steps.check_build_condition.outputs.needs_build == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ env.UPSTREAM_REPO }}
          ref: ${{ steps.get_upstream_sha.outputs.sha }}
          path: ${{ env.CORRETTO_SOURCE_DIR }}
          # Add verification
          token: ${{ github.token }}

      - name: Verify Checkout Integrity
        if: steps.check_build_condition.outputs.needs_build == 'true'
        working-directory: ${{ env.CORRETTO_SOURCE_DIR }}
        run: |
          # Verify we got the expected commit
          $actual_sha = (git rev-parse HEAD).Trim()
          $expected_sha = "${{ steps.get_upstream_sha.outputs.sha }}"
          
          if ($actual_sha -ne $expected_sha) {
            Write-Error "Checkout integrity check failed. Expected: $expected_sha, Got: $actual_sha"
            exit 1
          }
          Write-Host "Checkout integrity verified"
        shell: pwsh

      - name: Set up Corretto 21 as Bootstrap JDK (if build is needed)
        if: steps.check_build_condition.outputs.needs_build == 'true'
        uses: actions/setup-java@v4
        with:
          distribution: 'corretto'
          java-version: '21'
          architecture: x64

      - name: Install Visual Studio Build Tools Securely
        if: steps.check_build_condition.outputs.needs_build == 'true'
        run: |
          # Define allowed installation paths
          $allowedPaths = @(
            "C:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise",
            "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community", 
            "C:\\Program Files\\Microsoft Visual Studio\\2022\\Professional"
          )
          
          $installerPath = "C:\\Program Files (x86)\\Microsoft Visual Studio\\Installer\\vs_installer.exe"
          
          # Verify installer exists and is signed
          if (-not (Test-Path $installerPath)) {
            Write-Error "VS Installer not found at expected path"; exit 1
          }
          
          # Try installation with explicit path validation
          foreach ($installPath in $allowedPaths) {
            if (Test-Path $installPath) {
              Write-Host "Attempting VS modification for: $installPath"
              & $installerPath modify --installPath $installPath --add Microsoft.VisualStudio.Workload.NativeDesktop --includeRecommended --quiet --wait --norestart
              if ($LASTEXITCODE -eq 0) {
                Write-Host "VS Build Tools installation successful"
                break
              }
            }
          }
        shell: pwsh

      - name: Install Cygwin with Version Pinning
        if: steps.check_build_condition.outputs.needs_build == 'true'
        run: |
          # Install specific Chocolatey version first
          Set-ExecutionPolicy Bypass -Scope Process -Force
          [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
          
          # Download and verify Chocolatey installer
          $chocoUrl = "https://community.chocolatey.org/install.ps1"
          $chocoScript = Invoke-WebRequest -Uri $chocoUrl -UseBasicParsing
          
          # Basic content validation
          if ($chocoScript.Content -notmatch "chocolatey") {
            Write-Error "Chocolatey installer validation failed"; exit 1
          }
          
          Invoke-Expression $chocoScript.Content
          
          # Install Cygwin with specific parameters
          $cygwinParams = "/InstallDir:C:\\cygwin64 /NoAdmin"
          choco install cygwin --params $cygwinParams -y --no-progress
          
          # Verify installation
          $cygwinSetupPath = "C:\\cygwin64\\cygwinsetup.exe"
          if (-not (Test-Path $cygwinSetupPath)) {
            Write-Error "Cygwin installation verification failed"; exit 1
          }
          
          # Install required packages with explicit mirror
          $packages = "make,coreutils,diffutils,binutils,zip,unzip,autoconf,automake"
          $mirror = "https://mirrors.kernel.org/sourceware/cygwin/"
          
          # Use parameterized approach to prevent injection
          $setupArgs = @(
            "-q",
            "-s", $mirror,
            "-P", $packages
          )
          
          & $cygwinSetupPath @setupArgs
          
          # Add to PATH securely
          $cygwinBin = "C:\\cygwin64\\bin"
          if (Test-Path $cygwinBin) {
            echo $cygwinBin | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          } else {
            Write-Error "Cygwin bin directory not found"; exit 1
          }
        shell: pwsh

      - name: Configure Corretto Build Securely
        if: steps.check_build_condition.outputs.needs_build == 'true'
        working-directory: ${{ env.CORRETTO_SOURCE_DIR }}
        run: |
          $bootJdkWindows = $env:JAVA_HOME
          
          # Validate JAVA_HOME path
          if (-not $bootJdkWindows -or -not (Test-Path $bootJdkWindows)) {
            Write-Error "Invalid or missing JAVA_HOME"; exit 1
          }
          
          # Validate path format to prevent injection
          if ($bootJdkWindows -notmatch '^[a-zA-Z]:\\\\[^<>:"|?*]*$') {
            Write-Error "Invalid JAVA_HOME path format"; exit 1
          }
          
          # Securely convert path using cygpath
          try {
            $bootJdkCygwin = (& cygpath --unix $bootJdkWindows).Trim()
          } catch {
            Write-Error "Path conversion failed: $($_.Exception.Message)"; exit 1
          }
          
          # Validate converted path
          if (-not $bootJdkCygwin -or $bootJdkCygwin -match '[;&|`$]') {
            Write-Error "Invalid converted path"; exit 1
          }
          
          Write-Host "Bootstrap JDK (Windows): $bootJdkWindows"
          Write-Host "Bootstrap JDK (Cygwin): $bootJdkCygwin"
          
          # Use array for arguments to prevent injection
          $configureArgs = @(
            "./configure",
            "--with-boot-jdk=$bootJdkCygwin",
            "--disable-warnings-as-errors", 
            "--with-debug-level=release"
          )
          
          C:\\cygwin64\\bin\\bash -c ($configureArgs -join ' ')
        shell: pwsh

      - name: Build Corretto Securely
        if: steps.check_build_condition.outputs.needs_build == 'true'
        working-directory: ${{ env.CORRETTO_SOURCE_DIR }}
        run: |
          Write-Host "Starting secure build process"
          C:\\cygwin64\\bin\\bash -c "make images"
        shell: pwsh

      - name: Secure Debug Symbol Cleanup
        if: steps.check_build_condition.outputs.needs_build == 'true'
        working-directory: ${{ env.CORRETTO_SOURCE_DIR }}
        run: |
          # Use secure path resolution
          $buildDir = "build"
          if (-not (Test-Path $buildDir)) {
            Write-Error "Build directory not found"; exit 1
          }
          
          $jdkImagePath = Get-ChildItem -Path "$buildDir\\*\\images\\jdk" -Directory -ErrorAction SilentlyContinue | Select-Object -First 1
          
          if ($jdkImagePath) {
            # Validate path is within expected directory
            $fullPath = $jdkImagePath.FullName
            $expectedPattern = [regex]::Escape((Get-Location).Path)
            
            if ($fullPath -match "^$expectedPattern") {
              Write-Host "Cleaning debug symbols from: $fullPath"
              Get-ChildItem -Path $fullPath -Recurse -Include "*.pdb", "*.map" -ErrorAction SilentlyContinue | Remove-Item -Force -ErrorAction SilentlyContinue
              Write-Host "Debug symbol cleanup completed"
            } else {
              Write-Error "Invalid path detected during cleanup"; exit 1
            }
          } else {
            Write-Warning "JDK image directory not found for cleanup"
          }
        shell: pwsh

      - name: Prepare Artifact Structure Securely
        if: steps.check_build_condition.outputs.needs_build == 'true'
        id: prepare_artifact
        working-directory: ${{ env.CORRETTO_SOURCE_DIR }}
        run: |
          # Secure path resolution and validation
          $buildDir = "build"
          $jdkSourcePath = Get-ChildItem -Path "$buildDir\\*\\images\\jdk" -Directory -ErrorAction SilentlyContinue | Select-Object -First 1
          
          if (-not $jdkSourcePath) {
            Write-Error "JDK image directory not found"; exit 1
          }
          
          # Validate paths are within workspace
          $workspacePath = [regex]::Escape((Get-Location).Path)
          if ($jdkSourcePath.FullName -notmatch "^$workspacePath") {
            Write-Error "Security violation: Path outside workspace"; exit 1
          }
          
          $releaseFile = Join-Path $jdkSourcePath.FullName "release"
          if (-not (Test-Path $releaseFile)) {
            Write-Error "Release file not found"; exit 1
          }
          
          # Secure parsing of release file
          try {
            $releaseContent = Get-Content $releaseFile -Raw | ConvertFrom-StringData -Delimiter '='
            $javaVersion = $releaseContent.JAVA_VERSION.Trim('"')
            
            # Validate version format
            if (-not ($javaVersion -match '^[0-9.+_-]+$')) {
              Write-Error "Invalid Java version format"; exit 1
            }
          } catch {
            Write-Error "Failed to parse release file: $($_.Exception.Message)"; exit 1
          }
          
          echo "JAVA_VERSION_EXTRACTED=$javaVersion" >> $env:GITHUB_OUTPUT
          
          # Create staging directory with validation
          $stagingDir = Join-Path $env:GITHUB_WORKSPACE "staging_artifact"
          $targetDirName = "corretto-21-lilliput-$javaVersion"
          
          # Validate target directory name
          if ($targetDirName -notmatch '^[a-zA-Z0-9._-]+$') {
            Write-Error "Invalid target directory name"; exit 1
          }
          
          $fullTargetPath = Join-Path $stagingDir $targetDirName
          
          # Secure directory operations
          if (Test-Path $stagingDir) {
            Remove-Item -Recurse -Force $stagingDir -ErrorAction SilentlyContinue
          }
          
          New-Item -ItemType Directory -Path $fullTargetPath -Force | Out-Null
          
          # Secure file copying
          $sourceItems = Get-ChildItem -Path $jdkSourcePath.FullName -Force
          foreach ($item in $sourceItems) {
            Copy-Item -Path $item.FullName -Destination $fullTargetPath -Recurse -Force
          }
          
          Write-Host "Artifact prepared securely for version: $javaVersion"
        shell: pwsh

      - name: Upload Windows JDK Build Artifact
        if: steps.check_build_condition.outputs.needs_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: corretto-21-lilliput-${{ steps.prepare_artifact.outputs.JAVA_VERSION_EXTRACTED }}-windows-x64-jdk
          path: staging_artifact/
          retention-days: 30  # Limit retention for security

      - name: Update GitHub Repository Variable Securely
        if: steps.check_build_condition.outputs.needs_build == 'true' && success()
        env:
          NEW_SHA_TO_SAVE: ${{ steps.get_upstream_sha.outputs.sha }}
          GITHUB_TOKEN: ${{ github.token }}  # Use built-in token instead of PAT
        run: |
          # Validate SHA format before saving
          if [[ ! "$NEW_SHA_TO_SAVE" =~ ^[a-f0-9]{40}$ ]]; then
            echo "::error::Invalid SHA format for variable update"
            exit 1
          fi
          
          echo "Updating GitHub variable securely"
          
          # Use GitHub CLI with built-in token (more secure than PAT)
          if gh variable set "${{ env.GITHUB_VARIABLE_NAME }}" --body "$NEW_SHA_TO_SAVE" --repo "${{ github.repository }}"; then
            echo "GitHub variable updated successfully"
          else
            echo "::error::Failed to update GitHub variable"
            exit 1
          fi
        shell: bash
