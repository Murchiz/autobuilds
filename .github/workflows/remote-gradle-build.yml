name: Remote Gradle Builder

on:
  workflow_dispatch:
    inputs:
      repositories:
        description: 'Repositories to build (comma-separated: owner/repo, owner2/repo2)'
        required: true
        type: string
        default: 'owner/private-repo'
      
      advanced_config:
        description: 'Advanced JSON config (optional)'
        required: false
        type: string
        default: ''
      
      ref:
        description: 'Branch/tag/SHA'
        required: false
        default: ''
        type: string
      
      java_version:
        description: 'Java version'
        required: false
        default: '17'
        type: choice
        options: ['8', '11', '17', '21', '25']
      
      java_distribution:
        description: 'Java distribution'
        required: false
        default: 'temurin'
        type: choice
        options: [temurin, zulu, corretto, liberica, microsoft, oracle]
      
      gradle_tasks:
        description: 'Gradle tasks'
        required: false
        default: 'build'
        type: string
      
      gradle_args:
        description: 'Additional Gradle arguments'
        required: false
        default: '--no-daemon'
        type: string
      
      runner_os:
        description: 'Runner OS'
        required: false
        default: 'ubuntu-latest'
        type: choice
        options: [ubuntu-latest, ubuntu-22.04, windows-latest, macos-latest, macos-14]
      
      max_parallel:
        description: 'Max parallel jobs'
        required: false
        default: '5'
        type: choice
        options: ['1', '2', '3', '5', '10', '20']
      
      fail_fast:
        description: 'Fail fast on first failure'
        required: false
        default: false
        type: boolean
      
      upload_artifacts:
        description: 'Upload build artifacts'
        required: false
        default: true
        type: boolean
      
      enable_build_scan:
        description: 'Enable Gradle Build Scan'
        required: false
        default: false
        type: boolean

env:
  GRADLE_OPTS: "-Dorg.gradle.daemon=false -Dorg.gradle.parallel=true"
  # Use PAT for all git operations
  GH_TOKEN: ${{ secrets.REPO_ACCESS_TOKEN || github.token }}

jobs:
  setup-matrix:
    name: ğŸ“‹ Setup Build Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.create-matrix.outputs.matrix }}
      repo_count: ${{ steps.create-matrix.outputs.repo_count }}
    
    steps:
      - name: Validate token
        run: |
          if [ -z "${{ secrets.REPO_ACCESS_TOKEN }}" ]; then
            echo "::warning::REPO_ACCESS_TOKEN secret not set. Private repos will fail!"
            echo "â„¹ï¸ Using default GITHUB_TOKEN - only public repos will work"
          else
            echo "âœ… REPO_ACCESS_TOKEN is configured"
          fi

      - name: Create build matrix
        id: create-matrix
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.REPO_ACCESS_TOKEN || github.token }}
          script: |
            const advancedConfig = `${{ inputs.advanced_config }}`.trim();
            const defaultJava = '${{ inputs.java_version }}';
            const defaultTasks = '${{ inputs.gradle_tasks }}';
            const defaultRef = '${{ inputs.ref }}';
            const defaultArgs = '${{ inputs.gradle_args }}';
            const runnerOs = '${{ inputs.runner_os }}';
            
            let builds = [];
            
            if (advancedConfig && advancedConfig !== '') {
              try {
                const config = JSON.parse(advancedConfig);
                builds = config.map((item, index) => ({
                  index: index + 1,
                  repository: item.repo || item.repository,
                  ref: item.ref || item.branch || defaultRef || '',
                  java_version: String(item.java || item.java_version || defaultJava),
                  gradle_tasks: item.tasks || item.gradle_tasks || defaultTasks,
                  gradle_args: item.args || item.gradle_args || defaultArgs,
                  subproject: item.subproject || item.path || '',
                  runner: item.runner || item.os || runnerOs
                }));
              } catch (e) {
                core.setFailed(`Invalid JSON config: ${e.message}`);
                return;
              }
            } else {
              const repos = `${{ inputs.repositories }}`
                .split(',')
                .map(r => r.trim())
                .filter(r => r.length > 0);
              
              builds = repos.map((repo, index) => ({
                index: index + 1,
                repository: repo,
                ref: defaultRef,
                java_version: defaultJava,
                gradle_tasks: defaultTasks,
                gradle_args: defaultArgs,
                subproject: '',
                runner: runnerOs
              }));
            }
            
            if (builds.length === 0) {
              core.setFailed('No repositories specified');
              return;
            }
            
            // Validate repos and check accessibility
            for (const build of builds) {
              if (!build.repository.match(/^[\w.-]+\/[\w.-]+$/)) {
                core.setFailed(`Invalid repository format: ${build.repository}`);
                return;
              }
              
              // Check if repo is accessible
              try {
                const [owner, repo] = build.repository.split('/');
                await github.rest.repos.get({ owner, repo });
                console.log(`âœ… ${build.repository} - accessible`);
              } catch (e) {
                if (e.status === 404) {
                  core.setFailed(`âŒ Repository not found or not accessible: ${build.repository}. Check your REPO_ACCESS_TOKEN permissions.`);
                  return;
                }
                console.log(`âš ï¸ ${build.repository} - could not verify (${e.message})`);
              }
            }
            
            console.log(`\nğŸ“¦ Building ${builds.length} repositories`);
            
            const matrix = { include: builds };
            core.setOutput('matrix', JSON.stringify(matrix));
            core.setOutput('repo_count', builds.length);

  build:
    name: ğŸ”¨ Build ${{ matrix.repository }}
    needs: setup-matrix
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 60
    
    strategy:
      fail-fast: ${{ inputs.fail_fast }}
      max-parallel: ${{ fromJson(inputs.max_parallel) }}
      matrix: ${{ fromJson(needs.setup-matrix.outputs.matrix) }}
    
    steps:
      - name: ğŸ“¥ Checkout ${{ matrix.repository }}
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repository }}
          ref: ${{ matrix.ref || '' }}
          # THIS IS THE KEY FOR PRIVATE REPOS
          token: ${{ secrets.REPO_ACCESS_TOKEN || github.token }}
          fetch-depth: 0
          submodules: recursive
          # For private submodules, persist credentials
          persist-credentials: true

      # Configure git to use token for any additional fetches
      - name: ğŸ” Configure Git credentials
        run: |
          git config --global url."https://x-access-token:${{ secrets.REPO_ACCESS_TOKEN || github.token }}@github.com/".insteadOf "https://github.com/"
          git config --global url."https://x-access-token:${{ secrets.REPO_ACCESS_TOKEN || github.token }}@github.com/".insteadOf "git@github.com:"
        shell: bash

      - name: ğŸ” Detect Gradle configuration
        id: detect
        shell: bash
        run: |
          WORK_DIR="${{ matrix.subproject }}"
          WORK_DIR="${WORK_DIR:-.}"
          echo "work_dir=$WORK_DIR" >> $GITHUB_OUTPUT
          
          echo "ğŸ“‚ Repository: ${{ matrix.repository }}"
          
          if [ -f "$WORK_DIR/gradlew" ] || [ -f "$WORK_DIR/gradlew.bat" ]; then
            echo "has_wrapper=true" >> $GITHUB_OUTPUT
            chmod +x "$WORK_DIR/gradlew" 2>/dev/null || true
          else
            echo "has_wrapper=false" >> $GITHUB_OUTPUT
          fi
          
          if [ -f "$WORK_DIR/build.gradle.kts" ]; then
            echo "build_type=kotlin" >> $GITHUB_OUTPUT
          elif [ -f "$WORK_DIR/build.gradle" ]; then
            echo "build_type=groovy" >> $GITHUB_OUTPUT
          else
            echo "âŒ No build.gradle(.kts) found!"
            exit 1
          fi
          
          REPO_NAME=$(echo "${{ matrix.repository }}" | tr '/' '-')
          echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT

      - name: â˜• Set up JDK ${{ matrix.java_version }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java_version }}
          distribution: ${{ inputs.java_distribution }}
          cache: gradle

      - name: ğŸ˜ Setup Gradle
        uses: gradle/actions/setup-gradle@v4
        with:
          gradle-version: wrapper
          cache-read-only: false
          add-job-summary: always
          build-scan-publish: ${{ inputs.enable_build_scan }}
          build-scan-terms-of-use-url: "https://gradle.com/help/legal-terms-of-use"
          build-scan-terms-of-use-agree: "yes"

      # Handle private dependencies in build.gradle
      - name: ğŸ” Configure Gradle for private repos
        shell: bash
        run: |
          # Create or update gradle.properties with GitHub credentials
          mkdir -p ~/.gradle
          
          # Add GitHub token for GitHub Packages
          cat >> ~/.gradle/gradle.properties << EOF
          
          # GitHub Packages authentication
          gpr.user=${{ github.actor }}
          gpr.token=${{ secrets.REPO_ACCESS_TOKEN || github.token }}
          
          # Alternative property names some projects use
          GITHUB_USER=${{ github.actor }}
          GITHUB_TOKEN=${{ secrets.REPO_ACCESS_TOKEN || github.token }}
          github.user=${{ github.actor }}
          github.token=${{ secrets.REPO_ACCESS_TOKEN || github.token }}
          EOF
          
          echo "âœ… Gradle credentials configured"

      - name: ğŸ“¦ Install system Gradle (fallback)
        if: steps.detect.outputs.has_wrapper != 'true'
        shell: bash
        run: |
          if ! command -v gradle &> /dev/null; then
            if [[ "$RUNNER_OS" == "Linux" ]]; then
              sudo apt-get update && sudo apt-get install -y gradle
            elif [[ "$RUNNER_OS" == "macOS" ]]; then
              brew install gradle
            fi
          fi

      - name: ğŸ”¨ Build with Gradle
        id: build
        working-directory: ${{ steps.detect.outputs.work_dir }}
        shell: bash
        env:
          # Make token available to Gradle
          GITHUB_TOKEN: ${{ secrets.REPO_ACCESS_TOKEN || github.token }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          if [ "${{ steps.detect.outputs.has_wrapper }}" == "true" ]; then
            GRADLE_CMD="./gradlew"
            [[ "$RUNNER_OS" == "Windows" ]] && GRADLE_CMD="./gradlew.bat"
          else
            GRADLE_CMD="gradle"
          fi
          
          echo "ğŸš€ Building ${{ matrix.repository }}"
          echo "================================================"
          
          $GRADLE_CMD ${{ matrix.gradle_tasks }} ${{ matrix.gradle_args }} \
            --info \
            --stacktrace \
            -Dorg.gradle.jvmargs="-Xmx4g -XX:+HeapDumpOnOutOfMemoryError"

      - name: ğŸ“¦ Upload artifacts
        if: inputs.upload_artifacts && always()
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ steps.detect.outputs.repo_name }}-java${{ matrix.java_version }}
          path: |
            **/build/libs/*.jar
            **/build/libs/*.war
            **/build/distributions/*
          if-no-files-found: ignore
          retention-days: 14

      - name: ğŸ“Š Upload test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tests-${{ steps.detect.outputs.repo_name }}-java${{ matrix.java_version }}
          path: |
            **/build/reports/tests/**/*
            **/build/test-results/**/*
          if-no-files-found: ignore
          retention-days: 7

  summary:
    name: ğŸ“Š Build Summary
    needs: [setup-matrix, build]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Generate summary
        uses: actions/github-script@v7
        with:
          script: |
            const jobs = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            
            const buildJobs = jobs.data.jobs.filter(j => j.name.includes('Build'));
            
            let summary = '# ğŸ“Š Build Results\n\n';
            summary += '| Repository | Status | Duration |\n';
            summary += '|------------|--------|----------|\n';
            
            for (const job of buildJobs) {
              if (job.name === 'ğŸ“Š Build Summary') continue;
              
              const status = job.conclusion === 'success' ? 'âœ…' : 
                            job.conclusion === 'failure' ? 'âŒ' : 'â³';
              const duration = job.completed_at && job.started_at ? 
                Math.round((new Date(job.completed_at) - new Date(job.started_at)) / 1000) + 's' : '-';
              const name = job.name.replace('ğŸ”¨ Build ', '');
              
              summary += `| \`${name}\` | ${status} | ${duration} |\n`;
            }
            
            await core.summary.addRaw(summary).write();