name: Build Corretto 21 (lilliput-2) for Windows

on:
  schedule:
    - cron: '0 5 * * 1' # Every Monday at 05:00 UTC
  workflow_dispatch: # Allows manual triggering

env:
  UPSTREAM_REPO: corretto/corretto-21
  UPSTREAM_BRANCH: lilliput-2
  # Name of the GitHub Repository Variable used to store the last built upstream SHA
  GITHUB_VARIABLE_NAME: LAST_BUILT_CORRETTO_LILLIPUT_SHA
  # Directory where Corretto source will be checked out
  CORRETTO_SOURCE_DIR: corretto_source_checkout

jobs:
  build_if_new_commits:
    runs-on: windows-latest
    permissions:
      actions: write # Changed from 'variables: write'. Needed for updating repo variables via API.
      # contents: read # Default, needed for checkout actions if not checking out self

    steps:
      - name: Read Last Built Upstream SHA from GitHub Variable
        id: read_last_sha
        run: |
          $sha_from_var = "${{ vars[env.GITHUB_VARIABLE_NAME] || '' }}"
          echo "last_sha=$sha_from_var" >> $GITHUB_OUTPUT
          Write-Host "Last built upstream SHA read from variable '${{ env.GITHUB_VARIABLE_NAME }}': '$sha_from_var'"
        shell: pwsh

      - name: Get Current Upstream SHA for ${{ env.UPSTREAM_BRANCH }}
        id: get_upstream_sha
        run: |
          Write-Host "Fetching current SHA for ${{ env.UPSTREAM_REPO }}@${{ env.UPSTREAM_BRANCH }}"
          git clone --depth 1 --branch ${{ env.UPSTREAM_BRANCH }} https://github.com/${{ env.UPSTREAM_REPO }}.git temp_upstream_checkout
          cd temp_upstream_checkout
          $current_sha_ps_var = (git rev-parse HEAD).Trim() # Use distinct PS variable name
          cd ..
          Remove-Item -Recurse -Force temp_upstream_checkout

          Write-Host "Current upstream SHA determined for ${{ env.UPSTREAM_BRANCH }}: '$current_sha_ps_var'" # This correctly shows 7558e8...

          # --- CRITICAL FIX: Using Add-Content for setting step output ---
          Add-Content -Path $env:GITHUB_OUTPUT -Value "sha=$current_sha_ps_var"

          # For immediate verification within this step's log:
          Write-Host "Value written to GITHUB_OUTPUT for sha: $current_sha_ps_var"
          Write-Host "Path to GITHUB_OUTPUT: $env:GITHUB_OUTPUT"
          if (Test-Path $env:GITHUB_OUTPUT) {
            Get-Content $env:GITHUB_OUTPUT
          } else {
            Write-Warning "GITHUB_OUTPUT file does not exist at path: $env:GITHUB_OUTPUT"
          }
        shell: pwsh

      - name: Determine if Build is Needed
        id: check_build_condition
        run: |
          $last_sha = "${{ steps.read_last_sha.outputs.last_sha }}"
          $current_sha = "${{ steps.get_upstream_sha.outputs.sha }}"
          $needs_build_ps_var = "false" # Use a distinct PowerShell variable name

          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $needs_build_ps_var = "true"
            Write-Host "Manual dispatch (workflow_dispatch): Build is forced."
          } elseif ($last_sha -ne $current_sha) {
            $needs_build_ps_var = "true"
            Write-Host "Upstream SHA has changed (was '$last_sha', now '$current_sha'). Build needed."
          } else {
            Write-Host "Upstream SHA ('$current_sha') matches last built SHA. No build needed for scheduled run."
          }

          # Using Add-Content for setting step outputs
          Add-Content -Path $env:GITHUB_OUTPUT -Value "needs_build=$needs_build_ps_var"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "event_name_checked=${{ github.event_name }}"
          
          # For immediate verification within this step's log:
          Write-Host "Value written for needs_build: $needs_build_ps_var"
          Write-Host "Path to GITHUB_OUTPUT: $env:GITHUB_OUTPUT"
          Write-Host "Content of GITHUB_OUTPUT file after writing:"
          if (Test-Path $env:GITHUB_OUTPUT) {
            Get-Content $env:GITHUB_OUTPUT
          } else {
            Write-Warning "GITHUB_OUTPUT file does not exist at path: $env:GITHUB_OUTPUT"
          }
        shell: pwsh

      - name: Debug Build Condition Output
        run: |
          echo "Value of needs_build from previous step: '${{ steps.check_build_condition.outputs.needs_build }}'"
          echo "Value of event_name_checked from previous step: '${{ steps.check_build_condition.outputs.event_name_checked }}'"
          echo "Current github.event_name context: '${{ github.event_name }}'"
        shell: bash

      - name: Update GitHub Repository Variable with New SHA (if build succeeded)
        if: steps.check_build_condition.outputs.needs_build == 'true' && success()
        env:
          NEW_SHA_TO_SAVE: ${{ steps.get_upstream_sha.outputs.sha }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "NEW_SHA_TO_SAVE environment variable value: '${NEW_SHA_TO_SAVE}'"
          echo "GITHUB_VARIABLE_NAME environment variable value: '${GITHUB_VARIABLE_NAME}'"
          echo "GITHUB_REPOSITORY context value: '${GITHUB_REPOSITORY}'"

          if [ -z "${NEW_SHA_TO_SAVE}" ]; then
            echo "::error::NEW_SHA_TO_SAVE is empty. Cannot update GitHub variable."
            exit 1
          fi

          TARGET_VARIABLE_NAME="${GITHUB_VARIABLE_NAME}"
          TARGET_VARIABLE_VALUE="${NEW_SHA_TO_SAVE}"
          TARGET_REPOSITORY="${GITHUB_REPOSITORY}"

          # Corrected: Removed the leading slash from the API endpoint
          API_ENDPOINT="repos/${TARGET_REPOSITORY}/actions/variables/${TARGET_VARIABLE_NAME}" 
          
          echo "Attempting to update GitHub variable '${TARGET_VARIABLE_NAME}' to '${TARGET_VARIABLE_VALUE}' in repository '${TARGET_REPOSITORY}' via gh api"
          echo "API Endpoint for gh api: ${API_ENDPOINT}" # This will now be repos/...
          echo "Payload: name=${TARGET_VARIABLE_NAME}, value=${TARGET_VARIABLE_VALUE}"

          gh api \
            --method PUT \
            "${API_ENDPOINT}" \
            -f name="${TARGET_VARIABLE_NAME}" \
            -f value="${TARGET_VARIABLE_VALUE}" \
            --silent

          GH_API_EXIT_CODE=$?
          if [ ${GH_API_EXIT_CODE} -eq 0 ]; then
            echo "GitHub variable '${TARGET_VARIABLE_NAME}' updated successfully via gh api."
          else
            echo "::error title=API Update Failed (gh api)::Failed to update GitHub variable '${TARGET_VARIABLE_NAME}'. 'gh api' exited with code ${GH_API_EXIT_CODE}."
            # gh api should print API error details to stderr, which will appear in the logs.
            exit 1
          fi
        shell: bash

      # --- Conditional Build Steps Start Here (Unchanged from your last version) ---

      - name: Checkout Corretto source (if build is needed)
        if: steps.check_build_condition.outputs.needs_build == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ env.UPSTREAM_REPO }}
          ref: ${{ steps.get_upstream_sha.outputs.sha }}
          path: ${{ env.CORRETTO_SOURCE_DIR }}

      - name: Set up Corretto 21 as Bootstrap JDK (if build is needed)
        if: steps.check_build_condition.outputs.needs_build == 'true'
        uses: actions/setup-java@v4
        with:
          distribution: 'corretto'
          java-version: '21'
          architecture: x64
        id: setup_jdk

      - name: Install Visual Studio Build Tools (C++ workload) (if build is needed)
        if: steps.check_build_condition.outputs.needs_build == 'true'
        run: |
          echo "Ensuring Visual Studio C++ workload is installed..."
          & "C:\Program Files (x86)\Microsoft Visual Studio\Installer\vs_installer.exe" modify --installPath "C:\Program Files\Microsoft Visual Studio\2022\Enterprise" --add Microsoft.VisualStudio.Workload.NativeDesktop --includeRecommended --quiet --wait --norestart || `
          & "C:\Program Files (x86)\Microsoft Visual Studio\Installer\vs_installer.exe" modify --installPath "C:\Program Files\Microsoft Visual Studio\2022\Community" --add Microsoft.VisualStudio.Workload.NativeDesktop --includeRecommended --quiet --wait --norestart || `
          & "C:\Program Files (x86)\Microsoft Visual Studio\Installer\vs_installer.exe" modify --installPath "C:\Program Files\Microsoft Visual Studio\2022\Professional" --add Microsoft.VisualStudio.Workload.NativeDesktop --includeRecommended --quiet --wait --norestart || `
          echo "Visual Studio C++ workload check/install complete (or attempted)."
        shell: pwsh

      - name: Install Cygwin with necessary packages (if build is needed)
        if: steps.check_build_condition.outputs.needs_build == 'true'
        run: |
          choco install cygwin --params "/InstallDir:C:\cygwin64 /NoAdmin" -y
          $cygwinSetupPath = "C:\cygwin64\cygwinsetup.exe"
          if (-not (Test-Path $cygwinSetupPath -PathType Leaf)) { Write-Error "Cygwin setup executable ($cygwinSetupPath) not found!"; exit 1 }
          $cygwinPackages = "make,coreutils,diffutils,binutils,zip,unzip,autoconf,automake"
          $cygwinMirror = "http://mirrors.kernel.org/sourceware/cygwin/"
          Write-Host "Executing Cygwin setup ($cygwinSetupPath) to install packages: $cygwinPackages"
          try {
              Start-Process -FilePath $cygwinSetupPath -ArgumentList "-q -s $cygwinMirror -P $cygwinPackages" -Wait -NoNewWindow
              if ($LASTEXITCODE -ne 0) { Write-Error "Cygwin setup ($cygwinSetupPath) exited with code $LASTEXITCODE."; exit $LASTEXITCODE }
              Write-Host "Cygwin package installation command finished."
          }
          catch { Write-Error "Failed to start or execute '$cygwinSetupPath'. Error was: $($_.Exception.Message)"; exit 1 }
          echo "C:\cygwin64\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        shell: pwsh

      - name: Configure Corretto Build (if build is needed)
        if: steps.check_build_condition.outputs.needs_build == 'true'
        working-directory: ${{ env.CORRETTO_SOURCE_DIR }}
        run: |
          $BOOT_JDK_WINDOWS = $env:JAVA_HOME
          Write-Host "JAVA_HOME environment variable value: $BOOT_JDK_WINDOWS"
          if (-not $BOOT_JDK_WINDOWS) { Write-Error "Bootstrap JDK path from JAVA_HOME environment variable is empty!"; exit 1 }
          try {
              Get-Command cygpath -ErrorAction Stop | Out-Null
              $BOOT_JDK_CYGWIN = (& cygpath --unix $BOOT_JDK_WINDOWS).Trim()
          } catch { Write-Error "cygpath command not found or failed to convert '$BOOT_JDK_WINDOWS'. Error: $($_.Exception.Message)"; exit 1 }
          Write-Host "Using Bootstrap JDK (Windows path): $BOOT_JDK_WINDOWS"
          Write-Host "Using Bootstrap JDK (Cygwin path): $BOOT_JDK_CYGWIN"
          Write-Host "Running configure from PowerShell working directory: $(Get-Location)"
          C:\cygwin64\bin\bash -c "./configure --with-boot-jdk='$BOOT_JDK_CYGWIN' --disable-warnings-as-errors --with-debug-level=release"
        shell: pwsh

      - name: Build Corretto (make images) (if build is needed)
        if: steps.check_build_condition.outputs.needs_build == 'true'
        working-directory: ${{ env.CORRETTO_SOURCE_DIR }}
        run: |
          Write-Host "Running make from PowerShell working directory: $(Get-Location)"
          C:\cygwin64\bin\bash -c "make images"
        shell: pwsh

      - name: Clean Debug Symbols from JDK Image (if build is needed)
        if: steps.check_build_condition.outputs.needs_build == 'true'
        working-directory: ${{ env.CORRETTO_SOURCE_DIR }}
        run: |
          $jdkImagePath = Get-ChildItem -Path "build\*\images\jdk" -Directory | Select-Object -First 1 -ExpandProperty FullName
          if ($jdkImagePath) {
            Write-Host "Cleaning *.pdb and *.map files from $jdkImagePath"
            Get-ChildItem -Path $jdkImagePath -Recurse -Include "*.pdb", "*.map" | Remove-Item -Force -ErrorAction SilentlyContinue -Verbose
            Write-Host "Debug symbol cleanup complete."
          } else {
            Write-Warning "Could not find JDK image directory under build/*/images/jdk to clean."
          }
        shell: pwsh

      - name: Prepare Artifact Structure (if build is needed)
        if: steps.check_build_condition.outputs.needs_build == 'true'
        id: prepare_artifact
        working-directory: ${{ env.CORRETTO_SOURCE_DIR }}
        run: |
          $jdkSourcePath = Get-ChildItem -Path "build\*\images\jdk" -Directory | Select-Object -First 1 -ExpandProperty FullName
          if (-not $jdkSourcePath) { Write-Error "Could not find source JDK image directory under build/*/images/jdk"; exit 1 }
          Write-Host "Found JDK source path: $jdkSourcePath"
          $releaseFile = Join-Path $jdkSourcePath "release"
          if (-not (Test-Path $releaseFile)) { Write-Error "Could not find release file at $releaseFile"; exit 1 }
          $releaseContent = Get-Content $releaseFile -Raw | ConvertFrom-StringData -Delimiter '='
          $javaVersion = $releaseContent.JAVA_VERSION.Trim('"')
          if (-not $javaVersion) { Write-Error "Could not parse JAVA_VERSION from $releaseFile"; exit 1 }
          echo "JAVA_VERSION_EXTRACTED=$javaVersion" >> $GITHUB_OUTPUT
          $stagingDir = Join-Path $env:GITHUB_WORKSPACE "staging_artifact"
          $targetDirName = "corretto-21-lilliput-${javaVersion}"
          $fullTargetPathInStaging = Join-Path $stagingDir $targetDirName
          if (Test-Path $stagingDir) { Remove-Item -Recurse -Force $stagingDir }
          New-Item -ItemType Directory -Path $fullTargetPathInStaging | Out-Null
          Write-Host "Moving contents of $jdkSourcePath to $fullTargetPathInStaging"
          Move-Item -Path (Join-Path $jdkSourcePath "*") -Destination $fullTargetPathInStaging -Force
          Write-Host "Artifact prepared in staging directory: $stagingDir for JDK version $javaVersion"
        shell: pwsh

      - name: Upload Windows JDK Build Artifact (if build is needed)
        if: steps.check_build_condition.outputs.needs_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: corretto-21-lilliput-${{ steps.prepare_artifact.outputs.JAVA_VERSION_EXTRACTED }}-windows-x64-jdk
          path: staging_artifact/

      - name: Update GitHub Repository Variable with New SHA (if build succeeded)
        if: steps.check_build_condition.outputs.needs_build == 'true' && success()
        env:
          NEW_SHA_TO_SAVE: ${{ steps.get_upstream_sha.outputs.sha }} # This should now be 7558e8...
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Write-Host "NEW_SHA_TO_SAVE environment variable value: '$($env:NEW_SHA_TO_SAVE)'" # Debug
          Write-Host "GITHUB_VARIABLE_NAME environment variable value: '${{ env.GITHUB_VARIABLE_NAME }}'" # Debug
          Write-Host "GITHUB_REPOSITORY context value: '${{ github.repository }}'" # Debug

          # Ensure NEW_SHA_TO_SAVE is not empty before proceeding
          if (-not $env:NEW_SHA_TO_SAVE) {
            Write-Error "NEW_SHA_TO_SAVE is empty. Cannot update GitHub variable."
            exit 1
          }

          Write-Host "Attempting to update GitHub variable '${{ env.GITHUB_VARIABLE_NAME }}' to '$($env:NEW_SHA_TO_SAVE)' in repository '${{ github.repository }}' via REST API"

          $apiUrl = "https://api.github.com/repos/${{ github.repository }}/actions/variables/${{ env.GITHUB_VARIABLE_NAME }}"
          Write-Host "Constructed API URL: $apiUrl" # Debug

          $body = ConvertTo-Json @{
              name  = "${{ env.GITHUB_VARIABLE_NAME }}" # Ensure this is the variable name, not its value
              value = "$($env:NEW_SHA_TO_SAVE)"       # This is the new SHA
          }
          Write-Host "Request Body: $body" # Debug

          try {
              Invoke-RestMethod -Uri $apiUrl -Method Put -Headers @{
                  "Authorization"        = "Bearer $env:GH_TOKEN"
                  "Accept"               = "application/vnd.github+json"
                  "X-GitHub-Api-Version" = "2022-11-28"
              } -Body $body -ContentType "application/json"
              Write-Host "GitHub variable '${{ env.GITHUB_VARIABLE_NAME }}' updated successfully via REST API."
          } catch {
              Write-Error "Failed to update GitHub variable '${{ env.GITHUB_VARIABLE_NAME }}'."
              Write-Error "Status Code: $($_.Exception.Response.StatusCode)"
              Write-Error "Response Body: $($_.Exception.Response.Content | Out-String)" # Ensure full response is logged
              # For more detailed error info, if available:
              # Write-Error "Full Exception: $($_.ToString())"
              exit 1
          }
        shell: pwsh
